$sc-constants: (
  'decimal-space': ('0', '1', '2', '3', '4', '5', '6', '7', '8', '9'),
  'unit': ('px', 'cm', 'mm', '%', 'ch', 'pc', 'in', 'em', 'rem', 'pt', 'ex', 'vw', 'vh', 'vmin', 'vmax', 'ms', 's', 'deg', 'rad', 'grad', 'turn', 'Hz', 'kHz', 'dpi', 'dpcm', 'dppx'),
  'unit-value': (1px, 1cm, 1mm, 1%, 1ch, 1pc, 1in, 1em, 1rem, 1pt, 1ex, 1vw, 1vh, 1vmin, 1vmax, 1ms, 1s, 1deg, 1rad, 1grad, 1turn, 1Hz, 1kHz, 1dpi, 1dpcm, 1dppx)
);

/// Default return value for the `to-number(..)` function when running in
/// non-strict mode.
/// @access public
/// @type Number
$sc-non-strict-default-number: 0 !default;

/// Default return value for the `to-color(..)` function when running in
/// non-strict mode.
/// @access public
/// @type Number
$sc-non-strict-default-color: transparent !default;
/// Internal map for dynamically accessing default values for non-strict mode.
/// @access private
/// @type Map
$sc-non-strict-defaults: (
  'number': $sc-non-strict-default-number,
  'color': $sc-non-strict-default-color,
);

/// Helper function to throw when running in strict mode, or warn and return
/// default value for expected type when running in non-strict mode.
/// @param {*} $value
/// @param {String} $expected-type

@function _sc-throw($value, $expected-type) {
  $return-value: map-get($sc-non-strict-defaults, $expected-type);
  @return $return-value;
}

/// Tries to find a unit that would match a CSS length
/// @access private
/// @param {Number} $number - number
/// @param {String}   $unit - potential unit
/// @return {Number} length (0 if cast failed)

@function _sc-unit($number, $unit) {
  $units: map-get($sc-constants, 'unit-value');
  $index: index(map-get($sc-constants, 'unit'), $unit);

  @if not $index {
    @return _sc-throw($number, 'number');
  }

  @return ($number * nth($units, $index));
}


/// Cast a value to a number if possible or return 0
///
/// @author Hugo Giraudel
///
/// @link https://github.com/HugoGiraudel/SassyCast
///
/// @access public
///
/// @param {string} $value
///
/// @return {number}

@function to-number($value) {
  $type: type-of($value);

  // If the value is already a number, we can safely return it.
  @if ($type == 'number') {
    @return $value;
  }

  // If the value is the `true` boolean, we return 1.
  @if ($value == true)  {
    @return 1;
  }

  // If the value is the `false` boolean, we return 0.
  @if ($value == false) {
    @return 0;
  }

  // If the type is not a string, there is no way we can convert it to a number,
  // so we warn and return the default number value (or throw in strict mode).
  @if ($type != 'string') {
    @return _sc-throw($value, 'number');
  }

  // At this point we have discarded all the edge cases so we can start trying
  // to cast the value into a number.
  $pointer: 1;
  $result: 0;
  $first-character: str-slice($value, $pointer, $pointer);
  $allowed-first-character: join(('-', '.'), map-get($sc-constants, 'decimal-space'));

  // We perform an early check for errors. If value starts with neither a number
  // nor a minus sign, it cannot be casted to a number. Therefore we warn and
  // return the default number value (or throw in strict mode).
  @if not index($allowed-first-character, $first-character) {
    @return _sc-throw($value, 'number');
  }

  // In case the value starts with a dot, we assume it is a float and pad it
  // with a zero.
  @if ($first-character == '.') {
    $value: '0' + $value;
  }

  // We find the integer part of the value.
  $find-integer: find-integer($value, $pointer);
  $pointer: nth($find-integer, 1);
  $result:  nth($find-integer, 2);

  // If there still is a dot, it means we have to check for the digits part of
  // the value.
  @if (str-slice($value, $pointer, $pointer) == '.') {
    $find-digits: find-digits($value, $pointer);
    $pointer: nth($find-digits, 1);
    $digits:  nth($find-digits, 2);
    $result: ($result + $digits);
  }

  // If the first character is a minus symbol, it means the number is negative
  // so we can multiply it per -1.
  @if ($first-character == '-') {
    $result: ($result * -1);
  }

  // If we are still not done with the evaluation, it means there could be a CSS
  // unit, so we check for it.
  @if ($pointer <= str-length($value)) {
    $result: _sc-unit($result, str-slice($value, $pointer));
  }

  @return $result;
}
