/// Filter mixin that allows various syntax's
///
/// @author Mark Notton
///

///
/// @param {Map} $settings - Each argument should consist of a filter type and it's value
///
/// @require {variable} transform-types
/// @require {variable} transform-values
/// @require {function} arglist-to-list
/// @require {function} contains
/// @require {function} is-function
/// @require {function} is-string
///
/// @example scss - Usage
///   Doggy Style Syntax
///   @include filter(blur 5, sepia 100);
///   Bourbon Syntax
///   @include filter(blur(5), sepia(100));
///   Generic Syntax
///   @include filter(blur(5) sepia(100));
///
/// @example css - CSS Output
///   -webkit-filter: blur(5px) sepia(100%);
///   -moz-filter: blur(5px) sepia(100%);
///   filter: blur(5px) sepia(100%);
///

@mixin filter($settings...) {

  $filters : ();
  $fallback-settings : ();
  $important : null;

  @if not contains($filter-values, $settings, true) and length($settings) >= 1 {

    // This is an over-engineered section of code to to allow for all types of syntaxes.
    // Essestially making it work with Bourbon and other frameworks.
    @if length($settings) == 1  {
      @for $i from 1 through length($settings) {
        @each $setting in nth($settings, $i) {
          @if is-function($setting) {
            $fallback-settings : append($fallback-settings, $setting, comma);
          }
        }
      }
    }
    $settings-lists : if(length($fallback-settings) > 1, $fallback-settings,  arglist-to-list($settings));


    @each $settings in $settings-lists {

      @if is-function($settings) {
        $settings : is-function($settings);
      }

      $filter : null;
      $value : ();

      // Check for transforms
      @each $setting in $settings {
        @if is-string($setting) and contains($filter-types, $setting) {
          @if $setting == hue {
            $filter : hue-rotate;
          } @elseif $setting == shadow {
            $filter : drop-shadow;
          } @elseif $setting == greyscale {
            $filter : grayscale;
          } @else {
            $filter : $setting;
          }
        } @elseif is-bool($setting){
          $important : $setting;
        }
      }

      // Check and validate all transform types
      @each $setting in $settings {
        @if not is-string($setting) and not is-bool($setting) {
          @if contains($filter, (blur)) {
            // Values that require a unit
            $value : append($value, add-unit($setting));
          } @elseif contains($filter, (hue-rotate)) {
            // Values that require an angle
            $value : append($value, add-unit($setting, deg));
          } @elseif contains($filter, (invert opacity saturate sepia contrast grayscale)) {
            // Values that require an percent
            $value : append($value, add-unit($setting, '%'));
          } @elseif $filter == drop-shadow {
            // Specific for drop-shdaow
            @each $val in $setting {
              @if is-number($val) {
                $value : append($value, add-unit($val));
              } @elseif is-colour($val) {
                $value : append($value, $val);
              }
            }

          } @else {
            // All other values
            $value : append($value, $setting);
          }
        } @elseif contains($filter-values, $setting) {
          // Values that are strings and are global values
           $value : append($value, $setting);
        }
      }

      // Append transform and value to the transforms list
      @if $filter != null {
        $filters : append($filters, $filter+"("+$value+")");
      }

    }
  } @else {
   $filters : nth($settings, 1);
  }
  // @debug $filters;
  // @debug $important;
  filter : $filters $important;

}
