/// Quick mixin to devide a flex item using basis
///
/// @author Mark Notton
///
/// @access public
///
@mixin flex-grid($count, $gutter:$gap, $bottom:true, $important:false) {

  $gutter : strip-unit(to-number($gutter));

  @if $count <= 1 {
    @include flex-basis(auto, $important);
    width:100%;
    @if is-number($gutter) and $gutter != null $gutter > 0 {
      margin-right:0 $imp;
      @if $bottom { margin-bottom:add-unit(if(is-bool($bottom), $gutter, $bottom)); }
    }
  }
  @elseif $count > 1 {
    @if is-number($gutter) and $gutter != null {

      @include flex-basis(calc(100% / #{$count} - #{add-unit(($gutter * ($count - 1) / $count))}), $important);

      margin-right:add-unit($gutter);

      @for $i from 1 through $count {
        &:nth-of-type(#{$count + n}) {
          margin-right:0;
        }
      }
      @if $bottom {
        margin-bottom:add-unit(if(is-bool($bottom), $gutter, $bottom));
      }

    } @else {
      @include flex-basis(calc(100% / #{$count}), $important);
    }
  }
}

@mixin flex-grid-old($count, $gutter:$gap, $important:false) {
  @if $count <= 1 {
    @include flex-basis(auto, $important);
  }
  @elseif $count > 1 {
    @if is-number($gutter) and $gutter != null and $gutter > 0 {
      @include flex-basis(calc(100% / #{$count} - #{add-unit($gutter)} - 2px), $important);
    } @else {
      @include flex-basis(calc(100% / #{$count} - 2px), $important);
    }
  }
}

@function _get-next-breakpoint($setting) {
  @if is_number($setting) and contains(map-values($breakpoints), $setting) {
    // This gets the next available breakpoint from the list of breakpoints. The if-statment is a check if the last breakpoint item is queried.
    @return if(index(map-values($breakpoints), $setting) >= length(map-values($breakpoints)), null, nth(map-values($breakpoints), (index(map-values($breakpoints), $setting) + 1)));
  } @elseif is_string($setting) and map-has-key($breakpoints, $setting) {
    @return map-get-next($breakpoints, $setting);
  } @else {
    @return $setting;
  }
}

// 4 $gap $max, 2 0 $medium, $small
// 4, 2,
// @include smart-flex-grid('section', 3 $gap, 2 $gap0 $max, 1 $gap0 bottom $large);

@mixin smart-flex-grid($settings...) {
    $nth : 0;
    $selector : null;

    $settings-list : arglist-to-list($settings);

    $multiple-settings : length($settings-list) > 1;

    $sssbreak : null;

    // @debug $multiple-settings;

    @each $settings in $settings-list {

      @if (length($settings) == 1 and is-string(nth($settings, 1))) {
        // If the current element is the same one that was passed as the first param,
        // don't bother setting the $selector variable and revert to the more generic first of every element;
        @if last(last(to-list(&))) != $settings {
          $selector : $settings;
        } @else {
          $selector : '> *';
        }
        @include flex-container((direction:row, wrap:wrap, justify:stretch-between));
      } @else {

        $nth : $nth + 1;
        $count : null;
        $gutter : null;
        $grow : null;
        $break : null;
        $next-break : null;
        $gutter-position : ();
        $container : null;

        @each $setting in $settings {

          @if is_number($setting) {
            @if is_null($count) {
              $count : $setting;
            } @elseif is_null($gutter) {
              $gutter : $setting;
            } @elseif is_null($break) {
              // $next-break : _get-next-breakpoint($setting);
              $break : $setting;
            }
          }
          @if is_string($setting) {
            @if contains((top bottom left right all), $setting) {
              $gutter-position : append($gutter-position, $setting);
            } @elseif contains((grow), $setting) {
              $grow : true;
            } @elseif map-has-key($breakpoints, $setting) {
              // $next-break : _get-next-breakpoint($setting);
              $break : map-get($breakpoints, $setting);
            }
          }
          @if is_map($setting) {
            $container : $setting;
          }

              // $next-break : _get-next-breakpoint($setting);
          //@if is_null($break) and length($settings-list) >= 2 {
            // $break : nth($breakpoints, $nth);

            // @if $nth == 1 {
            //   // First
            //   $break : $max;
            //   $sssbreak : $max;
            // }



            // @if $nth != 1 {
            //   @debug $break;
            //   // Other settings
            //   $break : _get-next-breakpoint($sssbreak);
            // }
          //}
          // $break : if(is_null($break) and $nth == 1, $max, $break);
          // $next-break : if(is_null($next-break) and $multiple-settings and $nth != 1, _get-next-breakpoint($break), $next-break);
          // $break : if(is_null($break) and $nth != 1, $next-break, $break);
        }

        // Set default gutter position if not defined
        @if length($gutter-position) == 0 { $gutter-position : left right bottom }

        @if not is-null($container) {
          @include break($break) {
            @include flex-container($container);
            @debug $container;
          }
        }

        #{if(is-null($selector), '&', $selector)} {

          // max-width:100% / $count;

          @include break($break) {

            @if not is-null($grow) {
              @include flex-grow(1);
            }

            @if $count <= 1 {
              @include flex-basis(auto); @include flex-grow(1);
            }
            @elseif $count > 1 {
              @if is-number($gutter) and $gutter != null and strip-unit(to-number($gutter)) > 0 {
                @include flex-basis(calc(100% / #{$count} - #{add-unit($gutter)}));
              } @else {
                @include flex-basis(calc(100% / #{$count}));
              }
            }


            // // Margins and their positions
            // @if contains(left right, $gutter-position, true) {
            //   // $gutter-position contains BOTH left and right, and nothing more
            //   margin-left:add-unit($gutter/2);
            //   margin-right:add-unit($gutter/2);
            // } @elseif contains(top left, $gutter-position, true) {
            //   // $gutter-position contains BOTH top and bottom, and nothing more
            //   margin-top:add-unit($gutter/2);
            //   margin-bottom:add-unit($gutter/2);
            // } @elseif contains((left right top bottom), $gutter-position) {
            //   // $gutter-position contains EITHER left, right, top, bottom
            //   $gp : list-items-to-strings($gutter-position);

            //   @if index($gp, 'left') and index($gp, 'right') {
            //     margin-left:add-unit($gutter/2);
            //     margin-right:add-unit($gutter/2);
            //   } @else {
            //     margin-left  :if(index($gp, 'left'),   add-unit($gutter), null);
            //     margin-right :if(index($gp, 'right'),  add-unit($gutter), null);
            //   }
            //   @if index($gp, 'top') and index($gp, 'bottom') {
            //     margin-top:add-unit($gutter/2);
            //     margin-bottom:add-unit($gutter/2);
            //   } @else {
            //     margin-top:   if(index($gp, 'top'),    add-unit($gutter), null);
            //     margin-bottom:if(index($gp, 'bottom'), add-unit($gutter), null);
            //   }

            // } @elseif contains((all), $gutter-position) {
            //   margin:add-unit($gutter/2);
            // }

            // TODO: Fix issue of repeat CSS output. The above code is close.
            // Margins and their positions
            @if contains(left right, $gutter-position, true) {
              // $gutter-position contains BOTH left and right, and nothing more
              margin-left:add-unit($gutter/2);
              margin-right:add-unit($gutter/2);
            } @elseif contains(top left, $gutter-position, true) {
              // $gutter-position contains BOTH top and bottom, and nothing more
              margin-top:add-unit($gutter/2);
              margin-bottom:add-unit($gutter/2);
            } @elseif contains((left right top bottom), $gutter-position) {
              // $gutter-position contains EITHER left, right, top, bottom
              $gp : list-items-to-strings($gutter-position);
              $ml : null;
              $mr : null;
              $mt : null;
              $mb : null;

              @if index($gp, 'left') and index($gp, 'right') {
                $ml:add-unit($gutter/2);
                $mr:add-unit($gutter/2);
              }
              @if index($gp, 'top') and index($gp, 'bottom') {
                $mt:add-unit($gutter/2);
                $mb:add-unit($gutter/2);
              }

              @each $g in $gp {
                margin-left  : if(is-null($ml), if($g == 'left', add-unit($gutter), 0), $ml);
                margin-right : if(is-null($mr), if($g == 'right', add-unit($gutter), 0), $mr);
                margin-top   : if(is-null($mt), if($g == 'top', add-unit($gutter), 0), $mt);
                margin-bottom: if(is-null($mb), if($g == 'bottom', add-unit($gutter), 0), $mb);
              }

            } @elseif contains((all), $gutter-position) {
              margin:add-unit($gutter/2);
            }
          }
        }
        //}

        // $next-break : map-get-next($breakpoints, $break);

        // @debug "Setting: " + #{$nth};
        // @debug "count: " + #{$count};
        // @debug "gutter: " + #{$gutter};
        // @debug "break: " + #{$break};
        // @debug "next-break: " + #{$next-break};
        // @debug "gutter-positions: " + #{$gutter-position};
        // @debug "---";
      }

    }
}
