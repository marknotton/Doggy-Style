/// Quick mixin to devide a flex item using basis
///
/// @author Mark Notton
///
/// @access public
///
@mixin flex-grid($count, $gutter:$pad) {
  @if $count <= 1 {
    @include flex-basis(auto);
  }
  @elseif $count > 1 {
    @if is-number($gutter) and $gutter != null and strip(to-number($gutter)) > 0 {
      @include flex-basis(calc(100% / #{$count} - #{addUnit($gutter)}));
    } @else {
      @include flex-basis(calc(100% / #{$count}));
    }
  }
}

@function _get-next-breakpoint($setting) {
  @if is_number($setting) and contains(map-values($breakpoints), $setting) {
    // This gets the next available breakpoint from the list of breakpoints. The if-statment is a check if the last breakpoint item is queried.
    @return if(index(map-values($breakpoints), $setting) >= length(map-values($breakpoints)), null, nth(map-values($breakpoints), (index(map-values($breakpoints), $setting) + 1)));
  } @elseif is_string($setting) and map-has-key($breakpoints, $setting) {
    @return map-get-next($breakpoints, $setting);
  } @else {
    @return $setting;
  }
}

// 4 $pad $max, 2 0 $medium, $small
// 4, 2,
// @include smart-flex-grid('section', 3 $pad, 2 $pad0 $max, 1 $pad0 bottom $large);

@mixin smart-flex-grid($settings...) {
    $nth : 0;
    $selector : null;

    $settings-list : _arglist-to-list($settings);

    $multiple-settings : length($settings-list) > 1;

    $sssbreak : null;

    // @debug $multiple-settings;

    @each $settings in $settings-list {

      @if (length($settings) == 1 and is-string(nth($settings, 1))) {
        // If the current element is the same one that was passed as the first param,
        // don't bother setting the $selector variable and revert to the more generic first of every element;
        @if last(last(to-list(&))) != $settings {
          $selector : $settings;
        } @else {
          $selector : '> *';
        }
        @include flex-container((direction:row, wrap:wrap, justify:stretch-between));
      } @else {

        $nth : $nth + 1;
        $count : null;
        $gutter : null;
        $grow : null;
        $break : null;
        $next-break : null;
        $gutter-position : ();
        $container : null;

        @each $setting in $settings {

          @if is_number($setting) {
            @if is_null($count) {
              $count : $setting;
            } @elseif is_null($gutter) {
              $gutter : $setting;
            } @elseif is_null($break) {
              // $next-break : _get-next-breakpoint($setting);
              $break : $setting;
            }
          }
          @if is_string($setting) {
            @if contains((top bottom left right all), $setting) {
              $gutter-position : append($gutter-position, $setting);
            } @elseif contains((grow), $setting) {
              $grow : true;
            } @elseif map-has-key($breakpoints, $setting) {
              // $next-break : _get-next-breakpoint($setting);
              $break : map-get($breakpoints, $setting);
            }
          }
          @if is_map($setting) {
            $container : $setting;
          }

              // $next-break : _get-next-breakpoint($setting);
          //@if is_null($break) and length($settings-list) >= 2 {
            // $break : nth($breakpoints, $nth);

            // @if $nth == 1 {
            //   // First
            //   $break : $max;
            //   $sssbreak : $max;
            // }



            // @if $nth != 1 {
            //   @debug $break;
            //   // Other settings
            //   $break : _get-next-breakpoint($sssbreak);
            // }
          //}
          // $break : if(is_null($break) and $nth == 1, $max, $break);
          // $next-break : if(is_null($next-break) and $multiple-settings and $nth != 1, _get-next-breakpoint($break), $next-break);
          // $break : if(is_null($break) and $nth != 1, $next-break, $break);
        }

        // Set default gutter position if not defined
        @if length($gutter-position) == 0 { $gutter-position : left right bottom }

        @if not is-null($container) {
          @include break($break) {
            @include flex-container($container);
            @debug $container;
          }
        }

        #{if(is-null($selector), '&', $selector)} {

          // max-width:100% / $count;

          @include break($break) {

            @if not is-null($grow) {
              @include flex-grow(1);
            }

            @if $count <= 1 {
              @include flex-basis(auto); @include flex-grow(1);
            }
            @elseif $count > 1 {
              @if is-number($gutter) and $gutter != null and strip(to-number($gutter)) > 0 {
                @include flex-basis(calc(100% / #{$count} - #{addUnit($gutter)}));
              } @else {
                @include flex-basis(calc(100% / #{$count}));
              }
            }


            // // Margins and their positions
            // @if contains(left right, $gutter-position, true) {
            //   // $gutter-position contains BOTH left and right, and nothing more
            //   margin-left:addUnit($gutter/2);
            //   margin-right:addUnit($gutter/2);
            // } @elseif contains(top left, $gutter-position, true) {
            //   // $gutter-position contains BOTH top and bottom, and nothing more
            //   margin-top:addUnit($gutter/2);
            //   margin-bottom:addUnit($gutter/2);
            // } @elseif contains((left right top bottom), $gutter-position) {
            //   // $gutter-position contains EITHER left, right, top, bottom
            //   $gp : _list-items-to-strings($gutter-position);

            //   @if index($gp, 'left') and index($gp, 'right') {
            //     margin-left:addUnit($gutter/2);
            //     margin-right:addUnit($gutter/2);
            //   } @else {
            //     margin-left  :if(index($gp, 'left'),   addUnit($gutter), null);
            //     margin-right :if(index($gp, 'right'),  addUnit($gutter), null);
            //   }
            //   @if index($gp, 'top') and index($gp, 'bottom') {
            //     margin-top:addUnit($gutter/2);
            //     margin-bottom:addUnit($gutter/2);
            //   } @else {
            //     margin-top:   if(index($gp, 'top'),    addUnit($gutter), null);
            //     margin-bottom:if(index($gp, 'bottom'), addUnit($gutter), null);
            //   }

            // } @elseif contains((all), $gutter-position) {
            //   margin:addUnit($gutter/2);
            // }

            // TODO: Fix issue of repeat CSS output. The above code is close.
            // Margins and their positions
            @if contains(left right, $gutter-position, true) {
              // $gutter-position contains BOTH left and right, and nothing more
              margin-left:addUnit($gutter/2);
              margin-right:addUnit($gutter/2);
            } @elseif contains(top left, $gutter-position, true) {
              // $gutter-position contains BOTH top and bottom, and nothing more
              margin-top:addUnit($gutter/2);
              margin-bottom:addUnit($gutter/2);
            } @elseif contains((left right top bottom), $gutter-position) {
              // $gutter-position contains EITHER left, right, top, bottom
              $gp : _list-items-to-strings($gutter-position);
              $ml : null;
              $mr : null;
              $mt : null;
              $mb : null;

              @if index($gp, 'left') and index($gp, 'right') {
                $ml:addUnit($gutter/2);
                $mr:addUnit($gutter/2);
              }
              @if index($gp, 'top') and index($gp, 'bottom') {
                $mt:addUnit($gutter/2);
                $mb:addUnit($gutter/2);
              }

              @each $g in $gp {
                margin-left  : if(is-null($ml), if($g == 'left', addUnit($gutter), 0), $ml);
                margin-right : if(is-null($mr), if($g == 'right', addUnit($gutter), 0), $mr);
                margin-top   : if(is-null($mt), if($g == 'top', addUnit($gutter), 0), $mt);
                margin-bottom: if(is-null($mb), if($g == 'bottom', addUnit($gutter), 0), $mb);
              }

            } @elseif contains((all), $gutter-position) {
              margin:addUnit($gutter/2);
            }
          }
        }
        //}

        // $next-break : map-get-next($breakpoints, $break);

        // @debug "Setting: " + #{$nth};
        // @debug "count: " + #{$count};
        // @debug "gutter: " + #{$gutter};
        // @debug "break: " + #{$break};
        // @debug "next-break: " + #{$next-break};
        // @debug "gutter-positions: " + #{$gutter-position};
        // @debug "---";
      }

    }
}
