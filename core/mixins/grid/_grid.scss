$breakpoints: () !global;

// Quickly look for any matching breakpoint names and return their number
@function breaks($key) {
  @return map-fetch($breakpoints, $key);
}

// Add a breakpoint to a global map, which can be called on using the 'breaks' function
@mixin add-breakpoint($args...) {

  @for $i from 1 through length($args) {

    $name : null;
    $size : null;

    $arg: nth($args, $i);

    @each $rule in $arg {
      @if type-of($rule) == string {
        $name : $rule;
      }
      @if type-of($rule) == number {
        $size : strip($rule);
      }
    }

    $name : if($name == null and type-of($size) == number, #{$size}, $name);

    @if $name and $size {
      $breakpoints : map-set($breakpoints, $name, $size) !global;
    }
  }
  @at-root body { @include set-breakpoints(); }
}

// This will set a all the of the grid custom properties
@mixin set-breakpoints($breaks:$breakpoints) {
  $new-breakpoints : ();
  @each $break, $value in $breakpoints {
    $new-breakpoints : map-set( $new-breakpoints, #{breakpoint-}#{$break}, $value);
  }
  @include custom-property($new-breakpoints, null);
}

@mixin break($args) {

  @if (is-null($args)) {
    @content;
  } @else {
    $width : null;
    $condition : if($mobile-first, min-width, max-width);

    @each $rule in $args {
      @if is_number($rule) {
        $width : addUnit($rule);
      }
      @if is_string($rule) {
        $rule : if($rule == 'min', 'min-width', $rule);
        $rule : if($rule == 'max', 'max-width', $rule);
        $condition : $rule;
      }
    }

    // @if not contains($breakpoints, $width) {
    //   @include add-breakpoint($width);
    // }

    @media (#{$condition}:addUnit($width)) {
      @content;
    }
  }

}

@mixin hideAt($break) {
  @include break($break) {
    display:none;
    & { @content; }
  }
}

@mixin showAt($break) {
  @include break($break) {
    display:block;
    & { @content; }
  }
}




// The original grid mixin
@mixin grid($args, $gutter:null) {

  $count: nth($args, 1);
  $gutter: if($gutter == null, if(length($args) == 2, nth($args, 2), 0), $gutter);

  @if ($gutter == true) { $gutter:$gaps; }

  @if ($gutter != 0 or $count == 1) {
    @for $i from 1 through $count {
      @include nth($i, true) {
        clear:none; margin-right:addUnit($gutter);
      }
    }
    @include nth($count, true) { margin-right:0; }
  }

  @if ($count == 1) {
    @include nth($count, true) {
      margin-right:0;
    }
  }

  // Checks
  $width:     if($count  >  1, 100%/$count, 100%);
  $remainder: if($gutter != 0, #{'+ '} addUnit($gutter/$count), null);
  $gutter:    if($gutter != 0, #{'- '} addUnit($gutter), null);

  // Output
  float:left;
  @if ( $gutter != null ) {
    width:calc(#{$width} #{$gutter} #{$remainder});
  } @else {
    width:$width;
  }

    @content;

}

// @include grid(4 $gap $max, 2 0 $medium, $small);




// @mixin grid2($args...) {

// }




// Including the mixin for inner grid
// Specifying the pattern for a single row
// Which will be repeated for next rows
// .main {
//   .block { border:1px solid red; background-color:rc(); height:20px;}
//   //@include grid2(4, 2, 1);
// }
